# 数据结构——树

## 树与二叉树的定义

树是n个结点的有限集合。他的定义是递归的。在任一非空树中，有且仅有一个称为根节点的元素和其余若干个互不相交的有限子集。这些有限子集中的各个元素又是一棵树。

树具有严格的层次关系。

相关概念：
- 双亲、孩子、兄弟：
- 结点的度
- 叶子结点
- 内部结点
- 结点的层次
- 树的高度
- 有序（无序）树 

二叉树的定义：只有两个孩子的树

## 二叉树的性质与存储结构
性质：
1. 在第i层上最多有$2^{i-1}$个结点
2. 高度为k的二叉树最多有$2^k-1$个结点。
3. 令$n_0, n_2$分别为度为0、2的结点。则$n_0=n_2+1$
4. n个结点的完全二叉树的深度为$\lfloor {\log _2 n} \rfloor + 1$

存储结构：
对于顺序存储结构
假设有编号为i的结点。i从1开始
1. 若i = 1，无双亲，若i>1则双亲结点为$\lfloor i / 2\rfloor$
2. 若$2i \leq n$则结点的左孩子为2i，否则无左孩子。若$2i+1\leq n$则结点右孩子为2i+1

对于链式存储结构：
元素包含：数据、左子树结点、右子树结点

## 二叉树的遍历
使用递归方式。包括先序遍历、中序遍历、后续遍历。
先序遍历先遍历根节点
中序遍历先遍历左子树，再遍历根节点，最后遍历右子树。
后序遍历先遍历左右子树，再遍历根节点。

如果将递归方式转换成非递归方式，需要将一个栈

可以使用队列实现对二叉树的层序遍历。

## 线索二叉树
定义：将二叉树中的数据使用链表进行线性化结构的方法。
### 建立线索二叉树：
结构体：
```C
struct tagTree
{
    int ltag;
    struct tagTree* lchild;
    /****we have not shown the dataType */
    struct tagTree* rchild;
    int rtag;
}
```
通过中序遍历或者后续遍历将这些二叉树的信息串起来。
ltag和rtag为0时，相应域中的数据为左右节点的指针。否则则为前驱和后继结点。
如果没有对应左右孩子，那么对应tag值为1。

### 访问线索二叉树
若`C p->rtag==1`，则对应的rchild指向后继节点。反之指的是某个中序结点。

## 最优二叉树
### 最优二叉树
它又称之为哈夫曼树。他是一类带权路径的长度最短的树。路径是从树中的一个节点到另一个结点之间的最短路径。路径上的分支数目称之为路径长度。树的带权路径长度为树中所有叶子节点的带权路径长度之和。$$WPL=\sum ^n _{k=1}w_kl_k$$

构造方法：取最小值作为左右子树构造一个新的二叉树。将新的二叉树放进待构造的二叉树中。并删除这个最小值

### 哈夫曼编码
根据构造的哈夫曼树，记左方向为0，右方向为1. 将从根节点到相应元素的结点的编码记录为0.

## 树和森林

存储结构：双亲表示法、孩子表示法、孩子兄弟表示法

遍历：先根遍历、后根遍历

森林的遍历：先序遍历森林、中序遍历森林。

树、森林、二叉树之间的转换：将根节点放在一边，孩子放在另一边即可。