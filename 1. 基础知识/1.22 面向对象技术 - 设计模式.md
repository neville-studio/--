# 设计模式
## 要素
- 模式名称
- 问题
- 解决方案
- 效果

类别：
- 创建型
- 结构型
- 行为型

## 创建型设计模式
1. 抽象工厂模式


    提供创建一系列相关或相互依赖的接口，而无需指定他们具体的类
    成员：
      + AbstractFactory：抽象产品的接口
      + ConcreteFactory：具体创建产品的操作
      + AbstractFactory：抽象产品接口
      + ConcreteFactory：具体产品接口

    适用性：
    - 一个系统独立于它的产品创建、组合、表示
    - 要由多个产品对象设计以便联合使用
    - 多个产品系列要用同一个配置
    - 提供产品类库，强调接口而非实现

2. 生成器

    当一个复杂对象的构件与他的表示分离，使得同样的构件过程可以创建不同的表示
    成员：
    - Buildedr： 生成器指定的抽象接口
    - ConcreteBuilder：实现Builder接口以构造和装配产品部件。
    - Director：构造一个使用Builder接口的对象
    - Product：产生的对象
  
    适用性
    + 创建复杂对象算法独立于对象的组成方式以及它们的装配方式
    + 必须允许构造的对象有不同的表示方式

3. 工厂方法
   
   定义一个子接口，让子类决定实例化哪一个类。Factory Method使一个类延迟到其子类

   成员：
   + Product：定义工厂方法创建的对象接口
   + ConcreteProduct：实现Product接口
   + Creator：声明工厂方法，返回一个Product对象
   + ConcreteCreator：重定义工厂方法，返回一个ConcreteProduct类

    适用性：
    - 类不知道所必须创建的对象的类
    - 类希望它的子类来指定它创建的对象
    - 类对象的职责委托给子类中的一个
4. 原型模式
   
   用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象
   成员：
   - Prototype：声明一个复制自身的接口
   - ConcreteProtocols：实现复制自身的操作
   - Client：客户端

    适用性：
    - 系统独立于产品创建、构成、表示
    - 运行时指定实例化类
    - 避免创建一个产品类层次平行的工厂类层次
    - 实例只能有不同状态的一种，建立相应状态，并克隆会比较方便。

5. 单例模式
   保证一个类只有一个实例，并提供一个全局访问点
   适用性：
   - 只能有一个实例，客户可以从一个众所周知的访问点凡是顾问
   - 当这个唯一实例应该通过子类化扩展，并且客户无需更改代码就能使用一个扩展的实例

方法比较
1. 创建类的子类
2. 系统进行参数化
## 结构型设计模式
1. 适配器

    将一个类的接口转换成客户希望的另外一个接口。使得两个互不兼容的接口能在一起工作
    成员：
    + Target： 定义与Client使用的与特定领域相关的接口
    + Client：与符合Target接口的对象协同
    + Adaptee：定义一个已存在的接口，需要适配
    + Adapter：对Adaptee和Target进行适配
    
    适用性：
    - 使用存在的类，但是接口不符合要求
    - 创建一个可以复用的类，它可以与其他不想关的类协同工作
    - （对象Adapter）使用一个存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口，对象适配器可以适配它的父类接口

2. 桥接
   将抽象部分和实现部分剥离，使它们都可以独立地变化
   成员：
   - Abstraction：维护Implementor的接口
   - RedefinedAbstraction：扩充Abstraction接口
   - Implementor：定义实现类的接口。
   - ConcreteImplementor：事故宣布Implementor接口
  
   适用性：
   - 不希望抽象和实现有一个固定关系
   - 抽象及实现有它生成的子类的方法加以扩充
   - 对一个抽象的实现部分应对客户不产生影响（客户代码不需要编译）
   - 完全隐藏抽象的实现部分
   - 想在多个对象之间共享实现，但客户不知道

3. 组合
   将对象组合成树形结构表示“部分-整体”结构，使得组合对象的使用具有一致性
   
   成员：
   - Component： 对象声明接口
   - Leaf：叶子节点对象
   - Composite：定义子组件的组件行为
   - Client：通过Component接口组合成组件的对象

    适用性：
    - 表示对象的整体-部分组合结构
    - 忽略组合对象与单个对象的不同

4. 装饰
   动态的给一个对象添加一些额外的职责。

   成员：
   - Component：对象接口，动态添加职责
   - ConcreteComponent：定义对象，可以添加职责
   - Decorate：指向Component接口一致的接口
   - ConcreteDecorate：向组件添加职责
   
   适用性：
   - 动态、透明的方式给单个对象添加职责
   - 处理被撤销的职责
   - 不能采用生成子类的方式扩充或类定义不能用于生成子类

5. 外观：
   子系统中的一组接口提供一个一致的界面。

   成员：
   - Facade：知道哪些子系统负责处理请求，将客户的请求代理给适当的子系统对象
   - Subsystem classes：实现子系统的功能，处理Facade提供的任务

   适用性：
   - 给复杂的子系统提供一个简单的接口
   - 客户程序与抽象类之间存在的很大的依赖性
   - 需要构建一个层次的子系统时，使用Facade定义入口点

6. 享元
   使用共享技术有效地支持大量细粒度的对象

   成员：
   - Flyweight：接收并作用于外部对象的接口
   - ConcreteFlyweight：实现接口
   - 并非所有的Flyweight对象能被共享。需要在Flyweight的某些结构层次中实现。UnsharedConcentrateFlyweight为ConcreteFlyweight子节点
   - Flyweight：创建并管理Flyweight对象。
   - Client：保持引用
   
   适用性
   - 应用程序使用了大量对象
   - 使用大量对象造成存储开销
   - 对象大多数状态可变为外部状态
   - 删除外部状态，可以用相对少的共享对象取代多组对象
   - 应用程序不依赖于对象标识

7. 代理
   为其他对象提供一种代理以控制这个对象的访问

   成员：
   - Proxy：访问实体的代理类
   - Subject：定义RealSubject和Proxy的公用接口
   - RealSubject：被代理的实体类

   适用性：
   - 远程代理
   - 虚代理
   - 保护代理
   - 智能引用

## 行为设计模式
1. 责任链
   将对象连城一条链，沿着链传递请求，直到有个对象处理请求为之。

   成员：
   - Handler：处理接口
   - ConcreteHandler：具体处理接口
   - Client：客户端

   适用性：
   - 多个对象可以处理一个请求，但是哪个对象处理请求时自动确定
   - 不明确指定接收者对象
   - 处理一个对象的集合被动态指定

2. 命令
   将请求封装成一个对象，从而使得可以使用不同的请求对客户参数化，对请求排队或记录请求日志，以及可撤销操作

   成员
   - Command：操作的接口
   - ConcreteCommand：实现操作接口
   - Client：创建操作，指定接收
   - Invoker：要求执行请求
   - Receiver：用于接收结果
  
   适用性
   - 抽象除执行动作，参数化对象
   - 不同时刻处理请求
   - 支持取消操作
   - 支持修改日志
   - 构件原语基础上的高层操作构造一个系统

3. 解释器
   给定一个语言，定义一个文法的标识，定义解释器用于解释这个文法。

   成员：
   - AbstractExpression：抽象解释器操作
   - TerminalExpression：实现终结符相关联的解释操作
   - NonterminalExpression：实现解释操作
   - Context：解释器之外的全局信息记录
   - Client：构件、执行解释器
  
   适用性：
   - 文法简单
   - 效率不是问题（语法分析树实现）

4. 迭代器
   提供一种方法顺序访问一个聚合对象中的各个元素

   成员：
   - Iterator：迭代器，定义要迭代的对象
   - ConcreteIterator：实现迭代器接口；对改聚合遍历时跟踪当前位置
   - Aggregate：聚合定义相应迭代器对象的接口
   - ConcreteAggregate：具体实现迭代器接口

   适用性：
   - 访问一个聚合对象内容，无需暴露内部表示
   - 支持聚合对象多种遍历
   - 为遍历不同的聚合提供一个统一的接口

5. 中介者
   由中介对象封装一系列对象的交互，不需要相互引用，从而使得器耦合松散。

   成员
   - Mediator：中介者，实现各个同事对象通信
   - ConcreteMediator：具体中介者，具体实现各个同事
   - College：直到中介者对象，只能与中介者通信

   适用性
   - 复杂通信，相互依赖关系混乱
   - 难以复用对象
   - 定制一个分布多个类中的行为，不想产生太多子类。

6. 备忘录
   不破坏封装性的前提下捕获一个对象的内部状态，在对象之外保存这个状态，以便恢复。

   成员
   - Memento：备忘录，存放对象内部状态，存储备忘录存储的一些状态
   - Originator：原发器，用于创建备忘录，保存当前的状态。
   - Caretaker：管理者，保存好备忘录，对备忘录进行检查。

   适用性：
   - 保存某部分的状态
   - 防止暴露接口而破坏封装性

7. 观察者
   定义一对多依赖关系，当一个对象状态发生变化时，所有依赖于它的对象得到通知自动更新。

   成员
   * Subject：目标对象
   * Observer：观察者
   * ConcreteSubject：具体目标
   * ConcreteObeserver：具体观察者对象
   
   适用性：
   - 抽象模型有两个方面，依赖两个不同的对象
   - 对一个对象的改变要改变其他对象的引用
   - 一个对象必须通知其他对象，又不能确定对象是否是紧耦合的

8. 状态
   允许一个对象在其内部状态改变时改变行为。

   成员
   - Context：上下文对象，用于定义当前状态；
   - State：用于定义状态相关的行为
   - ConcreteState：定义具体状态子类
    
   适用性
   - 对象行为决定状态
   - 存在多分支语句时

9. 策略
    一个算法有多种替换模式的情况。

    成员：
    - Strategy：策略类
    - ConcreteStrategy：具体策略，实现算法
    - Context：上下文。维护引用，访问数据

    适用性：
    - 相关类只是行为有异
    - 使用算法的不同变体
    - 使用不应知道的数据
    - 类定义了多种行为，用于代替语句

10. 模板方法
    定义操作骨架，其余步骤延迟到子类实现。
    
    成员：
    - AbstractClass：定义抽象原语操作
    - ConcreteClass：定义具体层的相关操作

    适用性：
    - 一次性实现一个算法不变成分
    - 子类中的公共行为提取出来并集到一个公共父类，避免代码重复
    - 控制子类扩展

11. 访问者类
    表示一个作用于某对象结构中的各元素操作。

    成员：
    - Visitor：访问者
    - ConcreateVisitor：具体访问者
    - Element：访问元素的Accept操作
    - ConcreateElement：具体访问元素的操作
    - ObjectStructure：枚举元素

    适用性
    - 类对象很多，不同接口，用户想对某种具体类进行操作
    - 需要进行很多不相关且不同的操作
    - 对象结构的类很少改变，但是结构类上需要很多新的操作。

## 应用举例（略）